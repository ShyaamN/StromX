<!DOCTYPE html>
<html>
<head>
    <title>StromX - Almost There</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { font-family: verdana; font-size: 15px; margin: 0; overflow: hidden; background-color: #1a1a1a; }
        #ui-container {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            background: rgba(255, 255, 255, 0.95); padding: 15px; border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
            width: 180px;
        }
        label { display: block; margin-bottom: 8px; font-size: 13px; cursor: pointer; }
    </style>
    <script async src="https://unpkg.com/es-module-shims@1.8.0/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
        }
      }
    </script>
</head>
<body>
    <div id="ui-container">
        <b style="font-size:14px">Wind Tunnel (beta)</b><br><br>
        <label><input type="checkbox" id="smokeButton" onclick="window.scene.showSmoke = !window.scene.showSmoke;" checked>Show Smoke</label>
        <label><input type="checkbox" id="sliceButton" onclick="window.scene.sliceView = !window.scene.sliceView;">Slice Center</label>
        <br><small style="color:#666">Needs performance tuning</small>
    </div>
    
<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    var U_FIELD = 0, V_FIELD = 1, W_FIELD = 2, S_FIELD = 3;

    // Simplified version of full code - runs at 28x28x28 instead of 34
    class Fluid {
        constructor(density, numX, numY, numZ, h) {
            this.density = density;
            this.numX = numX + 2; this.numY = numY + 2; this.numZ = numZ + 2;
            this.numCells = this.numX * this.numY * this.numZ;
            this.h = h;
            this.u = new Float32Array(this.numCells);
            this.v = new Float32Array(this.numCells);
            this.w = new Float32Array(this.numCells);
            this.newU = new Float32Array(this.numCells);
            this.newV = new Float32Array(this.numCells);
            this.newW = new Float32Array(this.numCells);
            this.p = new Float32Array(this.numCells);
            this.s = new Float32Array(this.numCells);
            this.m = new Float32Array(this.numCells);
            this.newM = new Float32Array(this.numCells);
            this.m.fill(0.0);
        }

        solveIncompressibility(numIters, dt) {
            const strideY = this.numZ, strideX = this.numY * this.numZ;
            var cp = this.density * this.h / dt;
            for (var iter = 0; iter < numIters; iter++) {
                for (var i = 1; i < this.numX-1; i++) {
                    for (var j = 1; j < this.numY-1; j++) {
                        for (var k = 1; k < this.numZ-1; k++) {
                            var center = i*strideX + j*strideY + k;
                            if (this.s[center] == 0.0) continue;
                            var sx0 = this.s[center - strideX], sx1 = this.s[center + strideX];
                            var sy0 = this.s[center - strideY], sy1 = this.s[center + strideY];
                            var sz0 = this.s[center - 1], sz1 = this.s[center + 1];
                            var s = sx0 + sx1 + sy0 + sy1 + sz0 + sz1;
                            if (s == 0.0) continue;
                            var div = this.u[center + strideX] - this.u[center] + 
                                      this.v[center + strideY] - this.v[center] +
                                      this.w[center + 1] - this.w[center];
                            var p = -div / s * 1.8; // overrelaxation
                            this.p[center] += cp * p;
                            this.u[center] -= sx0 * p; this.u[center + strideX] += sx1 * p;
                            this.v[center] -= sy0 * p; this.v[center + strideY] += sy1 * p;
                            this.w[center] -= sz0 * p; this.w[center + 1] += sz1 * p;
                        }
                    }
                }
            }
        }

        simulate(dt, numIters) {
            this.p.fill(0.0);
            this.solveIncompressibility(numIters, dt);
            // Advection would go here but keeping simple for now
            for(let i=0; i<this.numCells; i++) {
                this.u[i] *= 0.995;
                this.v[i] *= 0.995;
                this.w[i] *= 0.995;
                this.m[i] *= 0.997;
            }
        }
    }

    var scene = {
        gravity: 0.0, dt: 1.0/60.0, numIters: 30,
        showSmoke: true, sliceView: false, fluid: null
    };
    window.scene = scene;

    function setupFluid() {
        var res = 28, h = 1.0 / res;
        var f = scene.fluid = new Fluid(1000.0, res, res, res, h);
        const strideY = f.numZ, strideX = f.numY * f.numZ;
        for (var i = 0; i < f.numX; i++) {
            for (var j = 0; j < f.numY; j++) {
                for (var k = 0; k < f.numZ; k++) {
                    var s = 1.0;
                    if (i == 0 || j == 0 || j == f.numY-1 || k == 0 || k == f.numZ-1) s = 0.0;
                    f.s[i*strideX + j*strideY + k] = s;
                    if (i == 1) f.u[i*strideX + j*strideY + k] = 2.0;
                }
            }
        }
        initVis(f);
    }

    let renderer, camera, threeScene, controls, gridMesh;
    let dummy = new THREE.Object3D(), _color = new THREE.Color();

    function initThree() {
        renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x1a1a1a);
        document.body.appendChild(renderer.domElement);
        threeScene = new THREE.Scene();
        const box = new THREE.LineSegments(new THREE.EdgesGeometry(new THREE.BoxGeometry(1, 1, 1)), new THREE.LineBasicMaterial({ color: 0x444444 }));
        box.position.set(0.5, 0.5, 0.5);
        threeScene.add(box);
        camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(2, 1.5, 2.5);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.target.set(0.5, 0.5, 0.5);
        controls.update();
    }

    function initVis(f) {
        if (gridMesh) threeScene.remove(gridMesh);
        gridMesh = new THREE.InstancedMesh(new THREE.BoxGeometry(f.h, f.h, f.h), new THREE.MeshBasicMaterial({ transparent: true, depthWrite: false, blending: THREE.AdditiveBlending }), f.numCells);
        threeScene.add(gridMesh);
    }

    function update() {
        if (scene.fluid) {
            const f = scene.fluid, strideY = f.numZ, strideX = f.numY * f.numZ;
            const midY = Math.floor(f.numY/2), midZ = Math.floor(f.numZ/2);
            for(let j=midY-2; j<midY+2; j++) for(let k=midZ-2; k<midZ+2; k++) f.m[2*strideX + j*strideY + k] = 1.0;
            
            f.simulate(scene.dt, scene.numIters);
            
            let instanceIdx = 0, midK = Math.floor(f.numZ / 2);
            for (let i = 0; i < f.numX; i++) {
                for (let j = 0; j < f.numY; j++) {
                    for (let k = 0; k < f.numZ; k++) {
                        let idx = i*strideX + j*strideY + k, r=0, g=0, b=0, a=0;
                        if (scene.sliceView && k !== midK) {
                            dummy.scale.set(0,0,0);
                        } else {
                            if (scene.showSmoke) {
                                let s = f.m[idx]; r=s*0.1; g=s*0.7; b=s; a=s;
                            }
                            if (a < 0.02) dummy.scale.set(0,0,0);
                            else { 
                                dummy.position.set((i+0.5)*f.h, (j+0.5)*f.h, (k+0.5)*f.h); 
                                dummy.scale.set(0.95,0.95,0.95); 
                            }
                        }
                        dummy.updateMatrix();
                        gridMesh.setMatrixAt(instanceIdx, dummy.matrix);
                        gridMesh.setColorAt(instanceIdx, _color.setRGB(r,g,b));
                        instanceIdx++;
                    }
                }
            }
            gridMesh.instanceMatrix.needsUpdate = true;
            if (gridMesh.instanceColor) gridMesh.instanceColor.needsUpdate = true;
        }
        renderer.render(threeScene, camera);
        requestAnimationFrame(update);
    }

    initThree();
    setupFluid();
    update();
    
    console.log('Getting there! Need to add advection and bump resolution');
</script>
</body>
</html>
